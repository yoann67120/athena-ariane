# ====================================================================
# üß† Athena.SelfRepair.psm1 ‚Äì Total Recovery Engine
# Version : v3.0-Ultimate (Self-Healing + AI Reconstruction + MemorySync)
# ====================================================================
# Objectifs :
#   - Scanner tous les modules et scripts pour d√©tecter anomalies ou corruptions
#   - R√©parer automatiquement via SafeOps, Backup ou reconstruction IA locale
#   - Valider les exports, recharger √† chaud, et historiser chaque action
#   - Alimenter LearningSummary.json et AutoRepairReport.json
#   - Pr√©venir les boucles et assurer la stabilit√© globale d‚ÄôAthena
# ====================================================================

Set-StrictMode -Version Latest
$ErrorActionPreference = 'SilentlyContinue'

# --- S√©curit√© Hash globale (d√©clar√©e avant tout le reste) ---
function global:Get-FileHashSafe {
    param([string]$Path)
    try {
        (Get-FileHash $Path -Algorithm SHA256).Hash
    }
    catch {
        return 'N/A'
    }
}

# ====================================================================
# üìÅ Initialisation des chemins
# ====================================================================
try {
    $ScriptRoot = $PSScriptRoot
    if (-not $ScriptRoot) { $ScriptRoot = Split-Path -Parent $PSCommandPath }
    $RootDir    = Split-Path -Parent $ScriptRoot
    $ModulesDir = Join-Path $RootDir 'Modules'
    $LogsDir    = Join-Path $RootDir 'Logs'
    $MemoryDir  = Join-Path $RootDir 'Memory'
    $BackupsDir = Join-Path $RootDir 'Backups'
    $DataDir    = Join-Path $RootDir 'Data\GPT'

    foreach ($p in @($LogsDir,$MemoryDir,$BackupsDir)) {
        if (!(Test-Path $p)) { New-Item -ItemType Directory -Path $p -Force | Out-Null }
    }

    $LogFile     = Join-Path $LogsDir 'AthenaSelfRepair.log'
    $ReportFile  = Join-Path $MemoryDir 'AutoRepairReport.json'
    $LearningSum = Join-Path $MemoryDir 'LearningSummary.json'
}
catch {
    Write-Warning "‚ö†Ô∏è Erreur d‚Äôinitialisation des chemins : $_"
    return
}

# ====================================================================
# üß© Fonctions utilitaires
# ====================================================================
function Write-RepairLog {
    param([string]$Message, [string]$Level = 'INFO')
    $t = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss')
    Add-Content -Path $LogFile -Value "[$t][$Level] $Message"
    Write-Host "ü©∫ $Message"
}

function Add-LearningEntry {
    param([string]$Module,[string]$Action,[string]$Result)
    $entry = [PSCustomObject]@{
        Date    = (Get-Date).ToString('u')
        Module  = $Module
        Action  = $Action
        Result  = $Result
    }
    $data = @()
    if (Test-Path $LearningSum) {
        try { $data = Get-Content $LearningSum -Raw | ConvertFrom-Json } catch {}
    }
    $data += @() + @() + $entry
    $data | ConvertTo-Json -Depth 4 | Out-File $LearningSum -Encoding UTF8
}

function Get-ModuleList {
    Get-ChildItem -Path $ModulesDir -Filter '*.psm1' -ErrorAction SilentlyContinue
}

function Get-FileHashSafe {
    param($Path)
    try { (Get-FileHash $Path -Algorithm SHA256).Hash } catch { return 'N/A' }
}

# ====================================================================
# üîç √âtape 1 ‚Äì Analyse d‚Äôint√©grit√©
# ====================================================================
function Test-AthenaModuleIntegrity {
    Write-Host "`nüîé Analyse de l‚Äôint√©grit√© des modules..." -ForegroundColor Cyan
    $modules = Get-ModuleList
    $report = @()

    foreach ($m in $modules) {
        try {
            $importable = $true
            try { Import-Module $m.FullName -Force -ErrorAction Stop } catch { $importable = $false }
            $hash = Get-FileHashSafe $m.FullName
            $size = [math]::Round($m.Length/1KB,2)
            $report += @() + @() + [PSCustomObject]@{
                Module = $m.Name
                Taille = "$size Ko"
                Hash   = $hash
                Importable = $importable
            }
        } catch {
            Write-RepairLog "Erreur analyse module $($m.Name) : $_" 'WARN'
        }
    }

    $report | ConvertTo-Json -Depth 3 | Out-File (Join-Path $MemoryDir 'IntegrityCheck.json') -Encoding utf8
    Write-Host "‚úÖ V√©rification d‚Äôint√©grit√© termin√©e." -ForegroundColor Green
    return $report
}

# ====================================================================
# üß© √âtape 2 ‚Äì R√©paration locale via SafeOps ou Backup
# ====================================================================
function Repair-AthenaModule {
    param([string]$Name)
    $Path = Join-Path $ModulesDir "$Name.psm1"
    Write-RepairLog "ü©π Tentative de r√©paration du module $Name..."

    # üîÅ 1. Restauration depuis SafeOps (.bak)
    $bak = Get-ChildItem "$Path.bak_*" -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1
    if ($bak) {
        Copy-Item $bak.FullName $Path -Force
        Import-Module $Path -Force -Global
        Write-RepairLog "‚úÖ Restauration depuis snapshot SafeOps : $($bak.Name)"
        Add-LearningEntry $Name 'SafeOpsRestore' 'Succ√®s'
        return
    }

    # üíæ 2. Copie depuis Backups
    $backupMatch = Get-ChildItem -Path $BackupsDir -Recurse -Filter "$Name.psm1" -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1
    if ($backupMatch) {
        Copy-Item $backupMatch.FullName $Path -Force
        Import-Module $Path -Force -Global
        Write-RepairLog "‚úÖ Module restaur√© depuis Backup : $($backupMatch.FullName)"
        Add-LearningEntry $Name 'BackupRestore' 'Succ√®s'
        return
    }

    # ü§ñ 3. Reconstruction IA locale
    if (Get-Command Invoke-LocalModel -ErrorAction SilentlyContinue) {
        Write-RepairLog "üß† Reconstruction IA du module $Name en cours..."
        $prompt = "Recr√©e le module PowerShell nomm√© '$Name' pour le projet ArianeV4. 
                   Il doit contenir au moins une fonction 'Invoke-$($Name -replace '\.','')' 
                   qui √©crit un message de confirmation. Format PowerShell complet."
        try {
            $code = Invoke-LocalModel -Prompt $prompt
            if ($code -and $code.Length -gt 20) {
                $code | Out-File -FilePath $Path -Encoding UTF8
                Import-Module $Path -Force -Global
                Write-RepairLog "‚úÖ Module $Name r√©g√©n√©r√© via IA locale."
                Add-LearningEntry $Name 'AIRebuild' 'Succ√®s'
            } else {
                Write-RepairLog "‚ùå √âchec de g√©n√©ration IA pour $Name" 'ERROR'
            }
        } catch {
            Write-RepairLog "‚ö†Ô∏è Erreur pendant la reconstruction IA : $_"
            Add-LearningEntry $Name 'AIRebuild' '√âchec'
        }
    } else {
        Write-RepairLog "‚ö†Ô∏è Moteur IA local non disponible pour $Name." 'WARN'
        Add-LearningEntry $Name 'AIRebuild' 'Non disponible'
    }
}

# ====================================================================
# ‚ôªÔ∏è √âtape 3 ‚Äì Cycle complet de r√©paration
# ====================================================================
function Invoke-AthenaSelfRepair {
    param([switch]$DryRun)

    Write-Host "`nü©∫ D√©marrage du processus complet de SelfRepair..." -ForegroundColor Cyan
    Write-RepairLog "=== Cycle complet lanc√© ==="

    $integrity = Test-AthenaModuleIntegrity
    $toFix = $integrity | Where-Object { -not $_.Importable -or $_.Taille -eq '0 Ko' }

    if ($toFix.Count -eq 0) {
        Write-RepairLog "‚úÖ Tous les modules sont intacts."
    } else {
        foreach ($m in $toFix) {
            if ($DryRun) {
                Write-RepairLog "[DRYRUN] Module $($m.Module) n√©cessiterait une r√©paration." 'INFO'
            } else {
                Repair-AthenaModule -Name ($m.Module -replace '\.psm1','')
            }
        }
    }

    # üß™ Test post-r√©paration
    Write-Host "`nüß™ V√©rification post-r√©paration..." -ForegroundColor Yellow
    try {
        $exports = Get-Command -Name "Invoke-Athena*" -ErrorAction SilentlyContinue
        Write-RepairLog "Exports disponibles : $($exports.Count)"
    } catch {
        Write-RepairLog "‚ö†Ô∏è √âchec de v√©rification post-r√©paration : $_"
    }

    # üßæ Rapport synth√©tique
    $summary = [PSCustomObject]@{
        Date = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss')
        ModulesAnalyzed = $integrity.Count
        ModulesRepaired = $toFix.Module
        Duration = "$([math]::Round(((Get-Date) - (Get-Content $LogFile | Select-Object -First 1)).Count,2))"
    }
    $summary | ConvertTo-Json -Depth 4 | Out-File $ReportFile -Encoding UTF8

    # üîä Annonce vocale finale
    try {
        Add-Type -AssemblyName System.Speech -ErrorAction Stop
        $s = New-Object System.Speech.Synthesis.SpeechSynthesizer
        $s.Rate = -1
        $s.SelectVoiceByHints([System.Speech.Synthesis.VoiceGender]::Female)
        $s.Speak("Cycle d'auto-r√©paration Athena termin√© avec succ√®s.")
    } catch {}

    Write-RepairLog "‚úÖ Cycle de SelfRepair termin√© avec succ√®s."
    Write-Host "`n‚úÖ Auto-r√©paration compl√®te effectu√©e." -ForegroundColor Green
}

# ====================================================================
# üìú Exportations
# ====================================================================
Export-ModuleMember -Function Invoke-AthenaSelfRepair, Test-AthenaModuleIntegrity, Repair-AthenaModule, Write-RepairLog
Write-Host "üß† Module Athena.SelfRepair.psm1 charg√© (v3.0-Ultimate ‚Äì Total Recovery Engine)." -ForegroundColor Cyan























# ‚úÖ Correctif appliqu√© le 17/10/2025 09:06 ‚Äì Add remplac√©.

# ‚úÖ Correctif appliqu√© le 17/10/2025 09:11 ‚Äì op_Addition remplac√©.




